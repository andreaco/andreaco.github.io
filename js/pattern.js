
class Pattern {
    _sequence;          /// Sequence array
    _timeSignature;     /// Time signature
    _vote;              /// Vote assigned by user

    /**
     * Constructor
     * @param {int} n_step Number of steps of the sequence
     * @param {Array} childSequence Useful to create a pattern by starting from an existing array (like the one generated by parents)
     */
    constructor(n_step, childSequence = undefined){
        if (n_step > 0 && childSequence === undefined) {
            this._sequence = Array(n_step).fill(0.0);
            this.generateRandomPattern();
        }
        else if(childSequence !== undefined) {
            this._sequence = childSequence   
        }
        else {
            console.error('Error: Could not create Pattern')
        }
    }

    /**
     * Getters
     */
    get steps() {        return this._sequence.length
    }
    get sequence() {
        return this._sequence
    }
    get vote() {
        return this._vote
    }

    /**
     * Setters
     */
    set vote(vote) {
        this._vote = vote;
    }

    /**
     * Function used to initialize the sequence to random values
     */
    generateRandomPattern() {
        for(let j=0; j < this._sequence.length; ++j) {
            if (Math.random()< 0.5){
                let velocity = Math.random();
                this._sequence[j] = velocity;
            }
        }
    }
    
    /**
     * Returns a child pattern by alternating from this parent and the other
     * @param {Pattern} matePattern Pattern to mate with
     * @param {int} index alternating factor (1 stands for 1 every other)
     */
    matingAlternate(matePattern, index = 1){ 
        let patternB = matePattern.sequence;
        let childPattern = this.sequence.slice();

        if(this.steps == matePattern.steps) {
            for(let i = index; i < childPattern.length; i+=2*index) {
                for (let j = 0 ; j < index; j++){
                    childPattern[i+j] = patternB[i+j]; 
                }
            }
            return new Pattern(0, childPattern);
        }
        else{
            console.error('Mating patterns have different size')
        } 
    }
    
    /**
     * Returns a child pattern by computing the logical AND
     * If two cells are both != from 0, keeps only this parent value
     * @param {Pattern} matePattern Pattern to mate with
     */
    matingAnd(matePattern){
        let patternB = matePattern.sequence;
        let childPattern = Array(this._sequence.length).fill(0.0);
        if(this.steps == matePattern.steps) {
            for (let i = 0; i < childPattern.length; i++){
                if(this.sequence[i] && patternB[i]) {
                    childPattern[i] = this.sequence[i];
                }
            }
            return new Pattern(0, childPattern);
        } 
        else{
            console.error('Mating patterns have different size')
        }
    }
}


class Offspring {
    _generation;        /// Current generation index
    _pool;              /// Array containing the patterns of current gen

    /**
     * Constructor generating a random pool with specified number of elements and steps
     * @param {int} n_elements Number of elements to be created in the pool 
     * @param {int} steps Number of steps for each element
     */
    constructor(n_elements, steps) {
        this._pool = Array(n_elements)
        this._generation = 0;
        for (let i = 0; i< n_elements; i++){
            this._pool[i] = new Pattern(steps)
        }
    }
    
    /**
     * Getters
     */
    get generation(){
        return this._generation;
    }
    get pool(){
        return this._pool;
    }
    get numberOfElements(){
        return this._pool.length;
    }

    /**
     * Function that allows the offspring to mate and advance to next generation
     * 
     * FIXME: funziona solo se c'è una pool con nelementi dispari
     */
    mating() {
        this._pool.sort((a,b) => (b.vote - a.vote))
        let newPool = Array(this.numberOfElements)
        newPool[0] = this._pool[0];
        for (let i = 1; i< this._pool.length; i+=2){
            newPool[i] = this._pool[i].matingAlternate(this._pool[i+1])
            newPool[i+1] = this._pool[i+1].matingAlternate(this._pool[i])
        }
        this._generation++;
        this._pool = newPool
    }
}